1 hstore kh√¥ng ph·∫£i l√† m·ªôt ki·ªÉu d·ªØ li·ªáu ƒë∆∞·ª£c t√≠ch h·ª£p s·∫µn (built-in) trong PostgreSQL theo m·∫∑c ƒë·ªãnh. N√≥ l√† m·ªôt extension (ph·∫ßn m·ªü r·ªông) m√† b·∫°n c·∫ßn ph·∫£i k√≠ch ho·∫°t (enable)
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE TABLE books (
    id serial PRIMARY KEY,
    title VARCHAR(255),
    attr hstore 
);
1.1 Ki·ªÉu hstore l∆∞u gi√° tr·ªã theo ki·ªÉu key => value: INSERT INTO books (title, attr)
VALUES
(
'Winds Of Winter',
'"paperback" => "2403",
"publisher" => "Bantam Spectra/US & Voyager Books/UK",
"language"  => "English",
"ISBN-13"   => "978-1449370000",
"weight"    => "13.2 ounces"'
),
Ch·ªçn ra key mu·ªën l·∫•y value :SELECT attr -> 'ISBN-13' AS isbn
FROM books;
- 2 Gi·∫£ s·ª≠ ch√∫ng ta c√≥ b·∫£ng sales v·ªõi c√°c c·ªôt brand, segment, v√† quantity nh∆∞ sau:

brand	segment	quantity
Apple	Mobile	100
Samsung	Mobile	150
Apple	Laptop	80
Dell	Laptop	120
Apple	Mobile	50
Samsung	Tablet	70
Dell	Desktop	90


SELECT brand, segment, SUM (quantity) FROM sales GROUP BY GROUPING SETS ( (brand, segment), (brand), (segment), () );

K·∫øt qu·∫£ trong PostgrSQL:

brand	segment	sum
Apple	Mobile	150
Samsung	Mobile	150
Apple	Laptop	80
Dell	Laptop	120
Samsung	Tablet	70
Dell	Desktop	90
Apple	NULL	230
Samsung	NULL	220
Dell	NULL	210
NULL	Mobile	250
NULL	Laptop	200
NULL	Tablet	70
NULL	Desktop	90
NULL	NULL	610

Gi·∫£i th√≠ch k·∫øt qu·∫£ PostgreSQL:



C√¢u l·ªánh MySQL t∆∞∆°ng ƒë∆∞∆°ng:


SELECT brand,segment,
SUM (quantity)
FROM
sales
GROUP BY
brand, segment

UNION ALL

SELECT
brand,
NULL AS segment,
SUM (quantity)
FROM
sales
GROUP BY
brand

UNION ALL

SELECT
NULL AS brand,
segment,
SUM (quantity)
FROM
sales
GROUP BY
segment

UNION ALL

SELECT
NULL AS brand,
NULL AS segment,
SUM (quantity)
FROM
sales;


K·∫øt qu·∫£ trong MySQL (t∆∞∆°ng ƒë∆∞∆°ng):

MySQL s·∫Ω tr·∫£ v·ªÅ m·ªôt t·∫≠p k·∫øt qu·∫£ c√≥ c√°c h√†ng t∆∞∆°ng t·ª± nh∆∞ tr√™n, ch·ªâ l√† th·ª© t·ª± c√°c h√†ng c√≥ th·ªÉ kh√°c nhau do UNION ALL kh√¥ng ƒë·∫£m b·∫£o th·ª© t·ª±.

brand	segment	SUM(quantity)
Apple	Mobile	150
Samsung	Mobile	150
Apple	Laptop	80
Dell	Laptop	120
Samsung	Tablet	70
Dell	Desktop	90
Apple	NULL	230
Samsung	NULL	220
Dell	NULL	210
NULL	Mobile	250
NULL	Laptop	200
NULL	Tablet	70
NULL	Desktop	90
NULL	NULL	610

L∆∞u √Ω v·ªÅ MySQL:

Th·ª© t·ª± c√°c h√†ng trong k·∫øt qu·∫£ c·ªßa MySQL c√≥ th·ªÉ kh√°c v·ªõi PostgreSQL v√¨ UNION ALL kh√¥ng duy tr√¨ th·ª© t·ª±. N·∫øu b·∫°n c·∫ßn m·ªôt th·ª© t·ª± c·ª• th·ªÉ, b·∫°n c√≥ th·ªÉ th√™m m·ªánh ƒë·ªÅ ORDER BY v√†o t·ª´ng c√¢u l·ªánh SELECT v√† c√≥ th·ªÉ th√™m m·ªôt c·ªôt ph·ª• ƒë·ªÉ ch·ªâ ƒë·ªãnh lo·∫°i nh√≥m tr∆∞·ªõc khi UNION ALL ƒë·ªÉ c√≥ th·ªÉ s·∫Øp x·∫øp k·∫øt qu·∫£ cu·ªëi c√πng. 
Tuy nhi√™n, ƒëi·ªÅu n√†y l√†m tƒÉng th√™m s·ª± ph·ª©c t·∫°p cho c√¢u l·ªánh.
V√≠ d·ª• n√†y l√†m r√µ c√°ch GROUPING SETS trong PostgreSQL cho ph√©p b·∫°n ƒë·ªãnh nghƒ©a nhi·ªÅu c√°ch nh√≥m d·ªØ li·ªáu trong m·ªôt truy v·∫•n duy nh·∫•t, t·∫°o ra m·ªôt t·∫≠p k·∫øt qu·∫£ t·ªïng h·ª£p ƒëa chi·ªÅu. N√≥ c≈©ng minh h·ªça c√°ch b·∫°n c√≥ th·ªÉ ƒë·∫°t ƒë∆∞·ª£c k·∫øt qu·∫£ t∆∞∆°ng t·ª± trong MySQL b·∫±ng c√°ch s·ª≠ d·ª•ng UNION ALL v√† nhi·ªÅu c√¢u l·ªánh GROUP BY ri√™ng bi·ªát.
- 3 Tuy·ªát v·ªùi, d·ª±a tr√™n h∆∞·ªõng d·∫´n v·ªÅ CUBE trong PostgreSQL t·ª´ link b·∫°n cung c·∫•p, ƒë√¢y l√† v√≠ d·ª• c·ª• th·ªÉ v·ªõi d·ªØ li·ªáu m·∫´u cho b·∫£ng sales v√† k·∫øt qu·∫£ c·ªßa c√¢u l·ªánh SELECT ... GROUP BY CUBE(...).

D·ªØ li·ªáu m·∫´u cho b·∫£ng sales:

Gi·∫£ s·ª≠ ch√∫ng ta v·∫´n s·ª≠ d·ª•ng b·∫£ng sales v·ªõi c√°c c·ªôt brand, segment, v√† quantity:

brand	segment	quantity
Apple	Mobile	100
Samsung	Mobile	150
Apple	Laptop	80
Dell	Laptop	120
Apple	Mobile	50
Samsung	Tablet	70
Dell	Desktop	90

C√¢u l·ªánh PostgreSQL s·ª≠ d·ª•ng CUBE:

sql SELECT brand, segment, SUM (quantity) FROM sales GROUP BY CUBE (brand, segment) ORDER BY brand, segment; -- Th√™m ORDER BY ƒë·ªÉ d·ªÖ ƒë·ªçc

K·∫øt qu·∫£ trong PostgreSQL:

brand	segment	sum
NULL	NULL	610
NULL	Desktop	90
NULL	Laptop	200
NULL	Mobile	250
NULL	Tablet	70
Apple	NULL	230
Apple	Laptop	80
Apple	Mobile	150
Apple	Tablet	NULL
Dell	NULL	210
Dell	Desktop	90
Dell	Laptop	120
Dell	Mobile	NULL
Dell	Tablet	NULL
Samsung	NULL	220
Samsung	Mobile	150
Samsung	Tablet	70
Samsung	Laptop	NULL

Gi·∫£i th√≠ch k·∫øt qu·∫£ PostgreSQL v·ªõi CUBE(brand, segment):

M·ªánh ƒë·ªÅ GROUP BY CUBE (brand, segment) t·∫°o ra c√°c nh√≥m cho t·∫•t c·∫£ c√°c t·ªï h·ª£p c√≥ th·ªÉ c·ªßa c√°c c·ªôt brand v√† segment, bao g·ªìm c·∫£ c√°c t·ªïng h·ª£p tr√™n t·ª´ng c·ªôt ri√™ng l·∫ª v√† t·ªïng h·ª£p to√†n b·ªô:

So s√°nh v·ªõi GROUPING SETS:

C√¢u l·ªánh tr√™n t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vi·ªác s·ª≠ d·ª•ng GROUPING SETS nh∆∞ sau:

sql SELECT brand, segment, SUM (quantity) FROM sales GROUP BY GROUPING SETS ( (brand, segment), (brand), (segment), () ) ORDER BY brand, segment;

Tuy nhi√™n, CUBE(brand, segment) t·ª± ƒë·ªông t·∫°o ra t·∫•t c·∫£ 2^n t·ªï h·ª£p nh√≥m c√≥ th·ªÉ (trong tr∆∞·ªùng h·ª£p n√†y n=2, n√™n c√≥ 2^2 = 4 t·ªï h·ª£p: (brand, segment), (brand), (segment), ()). ƒêi·ªÅu n√†y ti·ªán l·ª£i khi b·∫°n mu·ªën ph√¢n t√≠ch d·ªØ li·ªáu theo t·∫•t c·∫£ c√°c m·ª©c ƒë·ªô t·ªïng h·ª£p c√≥ th·ªÉ c·ªßa m·ªôt t·∫≠p h·ª£p c√°c c·ªôt.

L∆∞u √Ω:

Trong k·∫øt qu·∫£, b·∫°n s·∫Ω th·∫•y c√°c h√†ng c√≥ gi√° tr·ªã NULL ·ªü c√°c c·ªôt nh√≥m. NULL ·ªü ƒë√¢y kh√¥ng c√≥ nghƒ©a l√† gi√° tr·ªã th·ª±c t·∫ø l√† null trong d·ªØ li·ªáu g·ªëc, m√† n√≥ bi·ªÉu th·ªã r·∫±ng h√†ng ƒë√≥ l√† k·∫øt qu·∫£ c·ªßa vi·ªác t·ªïng h·ª£p tr√™n c√°c nh√≥m m√† c·ªôt ƒë√≥ kh√¥ng ƒë∆∞·ª£c xem x√©t (v√≠ d·ª•: h√†ng Apple | NULL | 230 l√† t·ªïng c·ªßa t·∫•t c·∫£ c√°c segment cho brand Apple).

ORDER BY brand, segment ƒë∆∞·ª£c th√™m v√†o ch·ªâ ƒë·ªÉ l√†m cho k·∫øt qu·∫£ d·ªÖ ƒë·ªçc v√† hi·ªÉu h∆°n.
- 4  SELECT brand, segment, SUM (quantity) FROM sales GROUP BY ROLLUP (brand, segment) ORDER BY brand, segment NULLS FIRST; 
K·∫øt qu·∫£ trong PostgreSQL:
brand	segment	sum
NULL	NULL	610
Apple	NULL	230
Apple	Laptop	80
Apple	Mobile	150
Dell	NULL	210
Dell	Desktop	90
Dell	Laptop	120
Samsung	NULL	220
Samsung	Mobile	150
Samsung	Tablet	70
Gi·∫£i th√≠ch k·∫øt qu·∫£ PostgreSQL v·ªõi ROLLUP(brand, segment):
M·ªánh ƒë·ªÅ GROUP BY ROLLUP (brand, segment) t·∫°o ra c√°c nh√≥m t·ªïng h·ª£p theo m·ªôt th·ª© b·∫≠c t·ª´ tr√°i sang ph·∫£i c·ªßa c√°c c·ªôt ƒë∆∞·ª£c li·ªát k√™:
T·ªïng h·ª£p theo t·∫•t c·∫£ c√°c c·ªôt: (brand, segment) - t∆∞∆°ng t·ª± nh∆∞ GROUP BY brand, segment.
T·ªïng h·ª£p theo c·ªôt ƒë·∫ßu ti√™n: (brand) - b·ªè qua c√°c c·ªôt theo sau.
T·ªïng h·ª£p to√†n b·ªô: () - b·ªè qua t·∫•t c·∫£ c√°c c·ªôt ƒë∆∞·ª£c li·ªát k√™ trong ROLLUP.
L∆∞u √Ω quan tr·ªçng v·ªÅ th·ª© t·ª±: Th·ª© t·ª± c·ªßa c√°c c·ªôt trong m·ªánh ƒë·ªÅ ROLLUP r·∫•t quan tr·ªçng. ROLLUP (brand, segment) s·∫Ω t·∫°o ra c√°c t·ªïng h·ª£p theo th·ª© t·ª±: (brand, segment), (brand), v√† (). 
N·∫øu b·∫°n ƒë·ªïi th·ª© t·ª± th√†nh ROLLUP (segment, brand), c√°c t·ªïng h·ª£p s·∫Ω theo (segment, brand), (segment), v√† ().
ROLLUP trong PostgreSQL v√† WITH ROLLUP trong MySQL ƒë·ªÅu cung c·∫•p kh·∫£ nƒÉng t·∫°o c√°c h√†ng t·ªïng h·ª£p theo m·ªôt th·ª© b·∫≠c x√°c ƒë·ªãnh b·ªüi th·ª© t·ª± c√°c c·ªôt trong m·ªánh ƒë·ªÅ GROUP BY.
- 5 Gi·∫£ s·ª≠ ch√∫ng ta c√≥ hai b·∫£ng:

B·∫£ng products:

product_id	product_name	price
1	Laptop Pro	1200
2	Mouse Wired	25
3	Keyboard RGB	75
4	Monitor 27"	300

B·∫£ng sales_info:

sale_id	product_id	discount_rate
101	1	0.10
102	3	0.05
103	1	0.15
104	4	0.08

M·ª•c ti√™u: Ch√∫ng ta mu·ªën c·∫≠p nh·∫≠t gi√° trong b·∫£ng products b·∫±ng c√°ch gi·∫£m gi√° d·ª±a tr√™n discount_rate trong b·∫£ng sales_info cho nh·ªØng s·∫£n ph·∫©m c√≥ trong c·∫£ hai b·∫£ng.

C√¢u l·ªánh PostgreSQL s·ª≠ d·ª•ng UPDATE v·ªõi JOIN:

UPDATE products
SET price = products.price * (1 - sales_info.discount_rate)
FROM sales_info
WHERE products.product_id = sales_info.product_id;


Gi·∫£i th√≠ch c√¢u l·ªánh PostgreSQL:

UPDATE products: Ch·ªâ ƒë·ªãnh b·∫£ng m√† ch√∫ng ta mu·ªën c·∫≠p nh·∫≠t (products).

SET price = products.price * (1 - sales_info.discount_rate): X√°c ƒë·ªãnh c·ªôt c·∫ßn c·∫≠p nh·∫≠t (price) v√† c√°ch t√≠nh gi√° tr·ªã m·ªõi. Ch√∫ng ta l·∫•y gi√° hi·ªán t·∫°i t·ª´ b·∫£ng products v√† nh√¢n v·ªõi (1 - discount_rate) l·∫•y t·ª´ b·∫£ng sales_info.

FROM sales_info: Ch·ªâ ƒë·ªãnh b·∫£ng m√† ch√∫ng ta s·∫Ω tham gia (sales_info).

WHERE products.product_id = sales_info.product_id: ƒêi·ªÅu ki·ªán JOIN ƒë·ªÉ li√™n k·∫øt c√°c h√†ng t·ª´ products v√† sales_info d·ª±a tr√™n c·ªôt product_id. Ch·ªâ nh·ªØng s·∫£n ph·∫©m c√≥ product_id tr√πng kh·ªõp trong c·∫£ hai b·∫£ng m·ªõi ƒë∆∞·ª£c c·∫≠p nh·∫≠t.

K·∫øt qu·∫£ sau khi ch·∫°y c√¢u l·ªánh PostgreSQL:

B·∫£ng products sau khi c·∫≠p nh·∫≠t:

product_id	product_name	price
1	Laptop Pro	1020.00
2	Mouse Wired	25.00
3	Keyboard RGB	71.25
4	Monitor 27"	276.00

L∆∞u √Ω: S·∫£n ph·∫©m c√≥ product_id = 2 (Mouse Wired) kh√¥ng c√≥ b·∫£n ghi t∆∞∆°ng ·ª©ng trong sales_info, v√¨ v·∫≠y gi√° c·ªßa n√≥ kh√¥ng b·ªã thay ƒë·ªïi. N·∫øu c√≥ nhi·ªÅu b·∫£n ghi trong sales_info cho c√πng m·ªôt product_id, h√†nh vi c·∫≠p nh·∫≠t c√≥ th·ªÉ kh√¥ng x√°c ƒë·ªãnh (trong v√≠ d·ª• n√†y, product_id = 1 xu·∫•t hi·ªán hai l·∫ßn trong sales_info, nh∆∞ng c√¢u l·ªánh s·∫Ω ch·ªâ th·ª±c hi·ªán c·∫≠p nh·∫≠t d·ª±a tr√™n vi·ªác c√≥ m·ªôt h√†ng kh·ªõp, c√≥ th·ªÉ l√† h√†ng ƒë·∫ßu ti√™n t√¨m th·∫•y). ƒê·ªÉ ki·ªÉm so√°t vi·ªác n√†y t·ªët h∆°n, b·∫°n c√≥ th·ªÉ c·∫ßn c√°c ƒëi·ªÅu ki·ªán JOIN ph·ª©c t·∫°p h∆°n ho·∫∑c s·ª≠ d·ª•ng c√°c ph∆∞∆°ng ph√°p kh√°c.

UPDATE JOIN t∆∞∆°ng t·ª± trong MySQL:

MySQL cung c·∫•p c√∫ ph√°p UPDATE v·ªõi JOIN tr·ª±c ti·∫øp s·ª≠ d·ª•ng t·ª´ kh√≥a JOIN (ho·∫∑c INNER JOIN, LEFT JOIN, v.v.) trong m·ªánh ƒë·ªÅ UPDATE:

UPDATE products
INNER JOIN sales_info ON products.product_id = sales_info.product_id
SET products.price = products.price * (1 - sales_info.discount_rate);

K·∫øt lu·∫≠n:

PostgreSQL v√† MySQL ƒë·ªÅu h·ªó tr·ª£ vi·ªác c·∫≠p nh·∫≠t d·ªØ li·ªáu trong m·ªôt b·∫£ng d·ª±a tr√™n d·ªØ li·ªáu t·ª´ m·ªôt b·∫£ng kh√°c th√¥ng qua ph√©p JOIN.

PostgreSQL s·ª≠ d·ª•ng c√∫ ph√°p UPDATE target_table SET ... FROM joined_table WHERE join_condition.

MySQL s·ª≠ d·ª•ng c√∫ ph√°p UPDATE target_table INNER JOIN joined_table ON join_condition SET ....
- 6 D·ªØ li·ªáu m·∫´u:

Gi·∫£ s·ª≠ ch√∫ng ta c√≥ b·∫£ng inventory v·ªõi c√°c c·ªôt product_id, quantity, v√† last_updated:

product_id	quantity	last_updated
1	100	2023-10-26 10:00:00
2	50	2023-10-26 10:00:00
3	75	2023-10-26 10:00:00

Ch√∫ng ta mu·ªën th·ª±c hi·ªán c√°c thao t√°c sau:

Th√™m m·ªôt s·∫£n ph·∫©m m·ªõi (product_id = 4) v·ªõi s·ªë l∆∞·ª£ng ban ƒë·∫ßu.

C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho m·ªôt s·∫£n ph·∫©m ƒë√£ t·ªìn t·∫°i (product_id = 1).

C√¢u l·ªánh PostgreSQL s·ª≠ d·ª•ng INSERT ON CONFLICT (UPSERT):

ƒê·ªÉ s·ª≠ d·ª•ng ON CONFLICT, ch√∫ng ta c·∫ßn m·ªôt r√†ng bu·ªôc UNIQUE tr√™n c·ªôt m√† ch√∫ng ta mu·ªën ki·ªÉm tra xung ƒë·ªôt. Trong tr∆∞·ªùng h·ª£p n√†y, product_id n√™n l√† UNIQUE. Ch√∫ng ta c√≥ th·ªÉ t·∫°o r√†ng bu·ªôc n√†y n·∫øu n√≥ ch∆∞a t·ªìn t·∫°i:

sql ALTER TABLE inventory ADD CONSTRAINT inventory_product_id_unique UNIQUE (product_id);

B√¢y gi·ªù, ch√∫ng ta c√≥ th·ªÉ th·ª±c hi·ªán UPSERT:

-- Th√™m s·∫£n ph·∫©m m·ªõi (product_id = 4)
INSERT INTO inventory (product_id, quantity, last_updated)
VALUES (4, 20, NOW())
ON CONFLICT (product_id) DO NOTHING;
-- V√¨ product_id = 4 ch∆∞a t·ªìn t·∫°i, h√†ng n√†y s·∫Ω ƒë∆∞·ª£c th√™m v√†o.

-- C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m ƒë√£ t·ªìn t·∫°i (product_id = 1)
INSERT INTO inventory (product_id, quantity, last_updated)
VALUES (1, 120, NOW())
ON CONFLICT (product_id) DO UPDATE SET
quantity = EXCLUDED.quantity,
last_updated = EXCLUDED.last_updated;
-- V√¨ product_id = 1 ƒë√£ t·ªìn t·∫°i, h√†ng s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t.
-- EXCLUDED ch·ª©a c√°c gi√° tr·ªã ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t cho h√†ng m·ªõi.

Gi·∫£i th√≠ch c√¢u l·ªánh PostgreSQL:

INSERT INTO inventory (product_id, quantity, last_updated) VALUES (...): ƒê√¢y l√† c√¢u l·ªánh INSERT th√¥ng th∆∞·ªùng ƒë·ªÉ ch√®n m·ªôt h√†ng m·ªõi v√†o b·∫£ng inventory.

ON CONFLICT (product_id): ƒêi·ªÅu kho·∫£n n√†y ch·ªâ ƒë·ªãnh c·ªôt m√† PostgreSQL s·∫Ω ki·ªÉm tra xung ƒë·ªôt UNIQUE. N·∫øu m·ªôt h√†ng v·ªõi product_id ƒë√£ t·ªìn t·∫°i, h√†nh ƒë·ªông sau DO s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán.

DO NOTHING: N·∫øu x·∫£y ra xung ƒë·ªôt (t·ª©c l√† product_id ƒë√£ t·ªìn t·∫°i), kh√¥ng th·ª±c hi·ªán h√†nh ƒë·ªông g√¨ c·∫£. Trong v√≠ d·ª• ƒë·∫ßu ti√™n, n·∫øu product_id = 4 ƒë√£ t·ªìn t·∫°i (ƒëi·ªÅu n√†y kh√¥ng x·∫£y ra trong d·ªØ li·ªáu ban ƒë·∫ßu), h√†ng m·ªõi s·∫Ω kh√¥ng ƒë∆∞·ª£c th√™m v√†o v√† h√†ng c≈© s·∫Ω kh√¥ng b·ªã thay ƒë·ªïi.

DO UPDATE SET quantity = EXCLUDED.quantity, last_updated = EXCLUDED.last_updated: N·∫øu x·∫£y ra xung ƒë·ªôt (t·ª©c l√† product_id ƒë√£ t·ªìn t·∫°i), h√£y th·ª±c hi·ªán l·ªánh UPDATE tr√™n h√†ng hi·ªán c√≥.

EXCLUDED l√† m·ªôt b·∫£ng ·∫£o ch·ª©a c√°c gi√° tr·ªã ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t trong c√¢u l·ªánh INSERT.

quantity = EXCLUDED.quantity c·∫≠p nh·∫≠t c·ªôt quantity c·ªßa h√†ng hi·ªán c√≥ b·∫±ng gi√° tr·ªã quantity t·ª´ c√¢u l·ªánh INSERT.

last_updated = EXCLUDED.last_updated t∆∞∆°ng t·ª±, c·∫≠p nh·∫≠t d·∫•u th·ªùi gian.

K·∫øt qu·∫£ sau khi ch·∫°y c√¢u l·ªánh PostgreSQL:

B·∫£ng inventory sau khi th·ª±c hi·ªán UPSERT:

product_id	quantity	last_updated
1	120	2023-10-27 08:00:00
2	50	2023-10-26 10:00:00
3	75	2023-10-26 10:00:00
4	20	2023-10-27 08:00:00

(L∆∞u √Ω: NOW() s·∫Ω tr·∫£ v·ªÅ th·ªùi gian hi·ªán t·∫°i khi b·∫°n ch·∫°y c√¢u l·ªánh, n√™n d·∫•u th·ªùi gian th·ª±c t·∫ø s·∫Ω kh√°c v·ªõi v√≠ d·ª• ban ƒë·∫ßu).

UPSERT t∆∞∆°ng t·ª± trong MySQL:

MySQL kh√¥ng c√≥ c√∫ ph√°p ON CONFLICT tr·ª±c ti·∫øp nh∆∞ PostgreSQL. Tuy nhi√™n, b·∫°n c√≥ th·ªÉ th·ª±c hi·ªán h√†nh vi UPSERT t∆∞∆°ng t·ª± b·∫±ng c√°ch s·ª≠ d·ª•ng c√∫ ph√°p INSERT ... ON DUPLICATE KEY UPDATE. ƒêi·ªÅu n√†y y√™u c·∫ßu b·∫£ng ph·∫£i c√≥ m·ªôt kh√≥a UNIQUE ho·∫∑c PRIMARY KEY tr√™n c·ªôt (ho·∫∑c t·ªï h·ª£p c·ªôt) m√† b·∫°n mu·ªën ki·ªÉm tra tr√πng l·∫∑p.

S·ª≠ d·ª•ng l·∫°i b·∫£ng inventory v√† ƒë·∫£m b·∫£o product_id l√† UNIQUE (n·∫øu ch∆∞a c√≥, h√£y t·∫°o index UNIQUE):

sql ALTER TABLE inventory ADD UNIQUE INDEX inventory_product_id_unique (product_id);

B√¢y gi·ªù, b·∫°n c√≥ th·ªÉ th·ª±c hi·ªán UPSERT trong MySQL nh∆∞ sau:

-- Th√™m s·∫£n ph·∫©m m·ªõi (product_id = 4) ho·∫∑c kh√¥ng l√†m g√¨ n·∫øu ƒë√£ t·ªìn t·∫°i
INSERT IGNORE INTO inventory (product_id, quantity, last_updated)
VALUES (4, 20, NOW());
-- INSERT IGNORE s·∫Ω b·ªè qua n·∫øu c√≥ l·ªói kh√≥a tr√πng l·∫∑p.

-- Th√™m s·∫£n ph·∫©m m·ªõi (product_id = 1) ho·∫∑c c·∫≠p nh·∫≠t n·∫øu ƒë√£ t·ªìn t·∫°i
INSERT INTO inventory (product_id, quantity, last_updated)
VALUES (1, 120, NOW())
ON DUPLICATE KEY UPDATE
quantity = VALUES(quantity),
last_updated = VALUES(last_updated);
-- N·∫øu product_id ƒë√£ t·ªìn t·∫°i, c√°c c·ªôt quantity v√† last_updated s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t
-- b·∫±ng c√°c gi√° tr·ªã ƒë∆∞·ª£c cung c·∫•p trong m·ªánh ƒë·ªÅ VALUES().

SELECT * FROM inventory;
``

Gi·∫£i th√≠ch c√¢u l·ªánh MySQL:

INSERT IGNORE INTO ...: N·∫øu b·∫°n c·ªë g·∫Øng ch√®n m·ªôt h√†ng c√≥ kh√≥a tr√πng l·∫∑p, MySQL s·∫Ω b·ªè qua l·ªói v√† h√†ng s·∫Ω kh√¥ng ƒë∆∞·ª£c ch√®n (v√† h√†ng c≈© s·∫Ω kh√¥ng b·ªã thay ƒë·ªïi). ƒêi·ªÅu n√†y t∆∞∆°ng ƒë∆∞∆°ng v·ªõi ON CONFLICT DO NOTHING trong PostgreSQL.

INSERT INTO ... ON DUPLICATE KEY UPDATE ...: N·∫øu b·∫°n c·ªë g·∫Øng ch√®n m·ªôt h√†ng g√¢y ra l·ªói tr√πng l·∫∑p kh√≥a (d·ª±a tr√™n kh√≥a UNIQUE ho·∫∑c PRIMARY KEY), MySQL s·∫Ω kh√¥ng b√°o l·ªói m√† thay v√†o ƒë√≥ s·∫Ω th·ª±c hi·ªán m·ªánh ƒë·ªÅ UPDATE.

VALUES(column_name): Trong m·ªánh ƒë·ªÅ ON DUPLICATE KEY UPDATE, VALUES(column_name) tham chi·∫øu ƒë·∫øn gi√° tr·ªã m√† b·∫°n ƒë√£ c·ªë g·∫Øng ch√®n cho column_name trong m·ªánh ƒë·ªÅ INSERT.

K·∫øt qu·∫£ sau khi ch·∫°y c√¢u l·ªánh MySQL (v·ªõi d·ªØ li·ªáu m·∫´u t∆∞∆°ng t·ª±):

B·∫£ng inventory sau khi th·ª±c hi·ªán UPSERT trong MySQL s·∫Ω cho k·∫øt qu·∫£ t∆∞∆°ng t·ª± nh∆∞ trong PostgreSQL:

product_id	quantity	last_updated
1	120	2023-10-27 08:00:00
2	50	2023-10-26 10:00:00
3	75	2023-10-26 10:00:00
4	20	2023-10-27 08:00:00

K·∫øt lu·∫≠n:

PostgreSQL cung c·∫•p c√∫ ph√°p INSERT ... ON CONFLICT ... DO NOTHING/UPDATE cho thao t√°c UPSERT, l√† m·ªôt ph·∫ßn c·ªßa chu·∫©n SQL g·∫ßn ƒë√¢y.

MySQL cung c·∫•p INSERT IGNORE INTO cho h√†nh vi "insert or do nothing" v√† INSERT ... ON DUPLICATE KEY UPDATE cho h√†nh vi "insert or update" d·ª±a tr√™n kh√≥a UNIQUE ho·∫∑c PRIMARY KEY.
- 7.1 TEMPORARY TABLE AS SELECT l√† g√¨?
üìå Kh√°i ni·ªám:
T·∫°o m·ªôt b·∫£ng t·∫°m th·ªùi t·ª´ m·ªôt truy v·∫•n SELECT.

B·∫£ng ch·ªâ t·ªìn t·∫°i trong phi√™n l√†m vi·ªác hi·ªán t·∫°i (session).

Khi session k·∫øt th√∫c (ng·∫Øt k·∫øt n·ªëi), b·∫£ng s·∫Ω t·ª± ƒë·ªông b·ªã x√≥a.

‚úÖ Khi n√†o n√™n d√πng:
Khi b·∫°n mu·ªën l∆∞u d·ªØ li·ªáu t·∫°m th·ªùi, v√≠ d·ª•: x·ª≠ l√Ω trung gian, ph√¢n t√≠ch b√°o c√°o, th·ªëng k√™,...

Tr√°nh ·∫£nh h∆∞·ªüng ƒë·∫øn d·ªØ li·ªáu th·∫≠t trong h·ªá th·ªëng.

CREATE TEMPORARY TABLE temp_users AS
SELECT * FROM users WHERE age > 30;

- 7.2  UNLOGGED TABLE l√† g√¨?
üìå Kh√°i ni·ªám:
L√† lo·∫°i b·∫£ng kh√¥ng ghi log (WAL - Write-Ahead Logging) nh∆∞ c√°c b·∫£ng b√¨nh th∆∞·ªùng trong PostgreSQL.

V√¨ kh√¥ng log, n√™n hi·ªáu nƒÉng ghi/ƒë·ªçc r·∫•t nhanh.

Nh∆∞ng n·∫øu h·ªá th·ªëng b·ªã t·∫Øt ƒë·ªôt ng·ªôt (crash), d·ªØ li·ªáu trong b·∫£ng n√†y s·∫Ω m·∫•t.

‚úÖ Khi n√†o n√™n d√πng:
D√πng trong c√°c t√°c v·ª• c·∫ßn x·ª≠ l√Ω r·∫•t nhanh, kh√¥ng c·∫ßn ƒë·∫£m b·∫£o d·ªØ li·ªáu t·ªìn t·∫°i sau crash:

ETL (tr√≠ch xu·∫•t d·ªØ li·ªáu - chuy·ªÉn ƒë·ªïi - t·∫£i l√™n)

T·∫°m th·ªùi l∆∞u d·ªØ li·ªáu cho b√°o c√°o

Ph√¢n t√≠ch log, audit t·∫°m
CREATE UNLOGGED TABLE fast_buffer AS
SELECT * FROM big_table WHERE status = 'active';
- 8 GENERATED ALWAYS AS IDENTITY m√† kh√¥ng c√≥ t√πy ch·ªçn n√†o kh√°c, n√≥ s·∫Ω b·∫Øt ƒë·∫ßu t·ª´ 1 v√† tƒÉng d·∫ßn 1.
CREATE TABLE products (
    id INT GENERATED ALWAYS AS IDENTITY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2)
);
CREATE TABLE categories (
    id INT GENERATED ALWAYS AS IDENTITY (START WITH 100 INCREMENT BY 10),
    name VARCHAR(50) NOT NULL
);
 id  |    name
-----+------------
 100 | Electronics
 110 | Books
(2 rows)
- 9 Composite Type:
CREATE TYPE address AS (
    street VARCHAR(100),
    city VARCHAR(50),
    postal_code VARCHAR(10)
);
Enum Type:
CREATE TYPE order_status AS ENUM ('pending', 'processing', 'shipped', 'delivered', 'cancelled');
Domain Type:
CREATE DOMAIN email AS VARCHAR(255) CHECK (VALUE LIKE '%@%.%');
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    shipping_address address,
    billing_address address,
    order_status order_status,
    contact_email email
);
PostgreSQL cung c·∫•p m·ªôt h·ªá th·ªëng m·∫°nh m·∫Ω cho vi·ªác ƒë·ªãnh nghƒ©a c√°c ki·ªÉu d·ªØ li·ªáu do ng∆∞·ªùi d√πng, bao g·ªìm Composite Types, Enum Types v√† Domain Types.
MySQL c√≥ h·ªó tr·ª£ cho Enum Types v√† Set Types
